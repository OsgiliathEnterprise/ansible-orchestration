---

- name: ansible-orchestration | kubernetes-ca-issued-certs | create kube-apiserver private key
  community.crypto.openssl_privatekey:
    path: "{{ kubernetes_certificates_path }}apiserver.key"
  become: true

- name: ansible-orchestration | kubernetes-ca-issued-certs | Check that the apiserver.crt exists
  stat:
    path: "{{ kubernetes_certificates_path }}apiserver.crt"
  when:
    - kube_masters_group in group_names
  register: api_server_cert_result

- name: ansible-orchestration | kubernetes-ca-issued-certs | retreive masters ip
  setup:
  register: kubemasterfacts
  delegate_facts: true

- name: ansible-orchestration | kubernetes-ca-issued-certs |  compute ip if preferred_nic is not set
  ansible.builtin.debug:
    msg: "{{ kubemasterfacts.ansible_facts['ansible_' + preferred_nic].ipv4.address if preferred_nic is defined else kubemasterfacts.ansible_facts.ansible_default_ipv4.address | default(kubemasterfacts.ansible_facts.ansible_all_ipv4_addresses[0]) }}" # TODO what if advertiseIP is not the main one
  register: kubemasterfacts_ip

- name: ansible-orchestration | kubernetes-ca-issued-certs | ensure dns entry is created
  freeipa.ansible_freeipa.ipadnsrecord:
    ipaadmin_password: "{{ company_realm_password }}"
    zone_name: "{{ company_domain }}"
    name: "api.kubernetes"
    a_ip_address: "{{ kubemasterfacts_ip.msg }}"
    state: present
  no_log: True
  delegate_to: "{{ groups[idm_group][0] }}" # TODO concat all masters IPs

- name: ansible-orchestration | kubernetes-ca-issued-certs | create kube-apiserver csr
  community.crypto.openssl_csr:
    path: "{{ kubernetes_certificates_path }}apiserver.csr"
    privatekey_path: "{{ kubernetes_certificates_path }}apiserver.key"
    country_name: "{{ kube_credential_country_name }}"
    organization_name: "{{ company_domain }}"
    email_address: "{{ kube_credential_email_address }}"
    common_name: "api.kubernetes.{{ company_domain }}"
    subject_alt_name: "{{ ['DNS:api.kubernetes.' + company_domain, 'DNS:' + hostname | default(machine_hostname.stdout), 'IP:' + kubemasterfacts_ip.msg] + (['DNS:'] | product(kube_alt_names) | map('join') | list) | default([]) | flatten }}" #, 'DNS:kubernetes', 'DNS:kubernetes.default', 'DNS:kubernetes.default.svc', 'DNS:kubernetes.default.svc.cluster', 'DNS:kubernetes.default.svc.cluster.local'
    key_usage:
      - digitalSignature
      - keyEncipherment
    extended_key_usage:
      - serverAuth
  when: not api_server_cert_result.stat.exists
  become: true

- name: ansible-orchestration | kubernetes-ca-issued-certs | configure http service
  freeipa.ansible_freeipa.ipaservice:
    ipaadmin_password: "{{ company_realm_password }}"
    name: "{{ item }}"
    host: "{{ hostname | default(machine_hostname.stdout) }}"
    skip_host_check: true
  delegate_to: "{{ groups[idm_group][0] }}"
  no_log: True
  loop:
   - "HTTP/api.kubernetes.{{ company_domain }}"
   - "HTTP/{{ hostname | default(machine_hostname.stdout) }}"

- name: ansible-orchestration | kubernetes-ca-issued-certs | create apiserver certificate
  shell: |
    set -o pipefail && echo '{{ company_realm_password }}' | kinit admin > /dev/null
    ipa cert-request {{ kubernetes_certificates_path }}apiserver.csr --profile-id=kubeAdministrators --ca=kubernetes-ca --principal='HTTP/api.kubernetes.{{ company_domain }}' --certificate-out={{ kubernetes_certificates_path }}apiserver.crt
  no_log: True
  when: not api_server_cert_result.stat.exists
  changed_when: False
  become: true

- name: ansible-orchestration | kubernetes-ca-issued-certs | create kube-apiserver-kubelet-client private key
  community.crypto.openssl_privatekey:
    path: "{{ kubernetes_certificates_path }}apiserver-kubelet-client.key"
  become: true

- name: ansible-orchestration | kubernetes-ca-issued-certs | Check that the kube-apiserver-kubelet-client.crt exists
  stat:
    path: "{{ kubernetes_certificates_path }}apiserver-kubelet-client.crt"
  register: api_server_kubelet_client_cert_result

- name: ansible-orchestration | kubernetes-ca-issued-certs | ensure dns entry is created
  freeipa.ansible_freeipa.ipadnsrecord:
    ipaadmin_password: "{{ company_realm_password }}"
    zone_name: "{{ company_domain }}"
    name: "kubelet.kubernetes"
    a_ip_address: "{{ kubemasterfacts_ip.msg }}"
    state: present
  no_log: True
  delegate_to: "{{ groups[idm_group][0] }}" # TODO concat all masters IPs

- name: ansible-orchestration | kubernetes-ca-issued-certs | configure http service
  freeipa.ansible_freeipa.ipaservice:
    ipaadmin_password: "{{ company_realm_password }}"
    name: "{{ item }}"
    host: "{{ hostname | default(machine_hostname.stdout) }}"
    skip_host_check: true
  no_log: True
  delegate_to: "{{ groups[idm_group][0] }}"
  loop:
   - "HTTP/kubelet.kubernetes.{{ company_domain }}"

- name: ansible-orchestration | kubernetes-ca-issued-certs | create kube-apiserver-kubelet-client csr
  community.crypto.openssl_csr:
    path: "{{ kubernetes_certificates_path }}apiserver-kubelet-client.csr"
    privatekey_path: "{{ kubernetes_certificates_path }}apiserver-kubelet-client.key"
    country_name: "{{ kube_credential_country_name }}"
    organization_name: "system:masters"
    email_address: "{{ kube_credential_email_address }}"
    common_name: "kubelet.kubernetes.{{ company_domain }}"
    key_usage:
      - digitalSignature
      - keyEncipherment
    extended_key_usage:
      - clientAuth
  when: not api_server_kubelet_client_cert_result.stat.exists
  become: true

- name: ansible-orchestration | kubernetes-ca-issued-certs | create kube-apiserver-kubelet-client certificate
  shell: |
    set -o pipefail && echo '{{ company_realm_password }}' | kinit admin > /dev/null
    ipa cert-request {{ kubernetes_certificates_path }}apiserver-kubelet-client.csr --profile-id=kubeAdministrators --ca=kubernetes-ca --principal='HTTP/kubelet.kubernetes.{{ company_domain }}' --certificate-out={{ kubernetes_certificates_path }}apiserver-kubelet-client.crt
  no_log: True
  when: not api_server_kubelet_client_cert_result.stat.exists
  changed_when: False
  become: true
